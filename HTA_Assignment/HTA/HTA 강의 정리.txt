javac.exe : 소스파일 -> byteCode 파일로 바꿔줌
java.exe : 자바 실행 application
통합개발환경(IDE) : Eclipse, IntelliJ 등..


타입의 형변환
숫자만 문자 타입으로 데이터 형변환 가능
형변환의 종류
- 자동 형변환 : 크기가 작은 타입의 값을 크기가 큰 타입의 값으로 변환 시 자동 변환된다.
ex) int a = 10, 
    long b = a;  =>자동 형변환 ok

- 수동 형변환 : 크기가 큰 타입의 값을 크기가 작은 타입의 값으로 변환 시 수동으로 선언해줘야 한다.
ex) long a = 100000L;
     int b = (int) a;
=================0324==================================
Scanner 클래스

   ㅇ구성 메소드
	-int nextInt()
	-long nextLong()
	-double nextDouble()
	-boolean nextBoolean()
	-String next()
	-String nextLine() : 입력이 완료될 때 까지 대기 (띄어쓰기 등도 받아옴)
	
분기 그래프 작성
	사각형 : 수행문
	마름모 : 조건식	


===========================0325 ===========================
객체가 갖고 있는 변수 = 속성 = 필드 = 프로퍼티
ex) arr.length

2+3+"가"+5+7 => "5가57" (문자열 만난순간부터 문자열로)

===========================0326===========================
String [][] names = new String[3][];
이런식일 경우 => 정방(직사각형 모양)의 배열이 아닌 배열로의 선언도 가능하다. = 비정방형 배열
ex) arr[0]->  ㅁㅁㅁ
     arr[1]->  ㅁㅁㅁㅁㅁ
     arr[2]->  ㅁㅁㅁㅁ
=>tip) for문으로 탐색 시, 내부 for문에 arr[1].length 등으로 조회

foreach tip => 2차원 배열의 각 요소에 접근 (String[][] arr)
  for(String[] x : arr){	=>x는 arr의 행, 
     for(String y : x){	=>y는 arr의 각 행의 열 값
        
  }
}

기본자료형 빼고는 변수에 모두 주소값이 저장된다
ex) int[] x, String x, Scanner sc => 모두 객체의 주소값


FIleCopy.java 소스파일 작성
javac FileCopy.java	 	실행파일 생성하는 명령어 실행
	FileCopy.class 	실행파일 생성됨
java FileCopy 		실행파일 실행하는 명령어 실행



VO(Value Object), DTO : 값을 담고 있는 객체


설계도(클래스)			설계도(클래스)
개발자용 	------->	javac.exe	------->	JVM용
String.java====> String.class ------>  String.class

=================0329==================================
== : 기본 타입의 비교
.equals : 객체의 비교

q) 기본형으로 선언된 변수의 메모리 영역은?


<클래스>
캡슐화 : 은닉성
응집도 : 관련성 있는 메소드들이 얼마나 모여있나
다형성 : 어떤 객체를 갖다 쓰느냐에 따라 같은 기능이어도 다른 결과를 나타낸다
	ex) db에서 데이터 가져와서 출력,
	     클라우드에서 데이터 가져와서 출력

	    이 문서는 컬러로 출력,
	    저 문서는 흑백으로 출력

속성: 멤버변수(=필드)
기능: 메서드

tip) 클래스명에 App가 붙으면 main메서드를 갖고 있는 클래스
     클래스 출력할 때 생성되는 day1.Book@5aaa6d82 
                      객체 타입(클래스) : 앞쪽@뒤쪽 : 해쉬코드(주소아님)
     ex) Product p1 = new Product();
          sysout(p1);



변수 : 메서드 안에서 정의
필드 : 클래스 안에서 정의(=멤버변수)

필드(속성(값)) - 공유
-메소드
-메소드
-메소드
-메소드

******
new하는 순간 메모리(힙)에 아래와 같이 세팅됨
기본자료형 변수 : 디폴트값이 들어감 (0, false,...)
ex) int => 0
참조자료형 변수 : null값이 들어감(참조변수의 기본값은 null)
참조변수가 더 이상 객체 참조하지 않기 =>
book1 = null;


******
생성된 객체를 어떤 변수도 참조하고 있지 않으면 그 순간 Garbage가 된다.
이후 GarbageCollector에 의해 메모리 반환됨 (단, Garbage가 되는 순간 메모리가 청소되는 것은 아니다)
	ex)
	Product p1 = new Product();
	Product p2 = p1;
	p1 = null;
	p2 = null;
	System.out.println(p1.name); //nullPointerException 발생


자바에서는 예외 발생 시, Exception이라는 객체가 만들어지고 반환해준다.
ex) nullPointerException

===========================0330=========================
참조변수가 null이면 아무 작업도 못한다.
ex) Product item = null
    1. item.equals("애플") => 널포인터 에러 발생
    2. "애플".equals("애플") => 이 땐 널포인터 에러 발생안한다.  => 문자열 비교할 땐 이런식으로 비교할 것

/**  
*	: 자바 도큐먼트 주석 : 사용자가 지정한 메소드에 설명을 달아준다(마우스 올려놓으면 설명 뜸)
*/

===========================0331===========================
클래스 변수 = 정적변수 = 정적 필드 = 클래스 필드
인스턴스 변수는 객체 생성될 떄마다 하나씩 생성
static 변수는 클래스가 맨 처음 로딩될 때 한 번 생성
클래스가 로딩되는 순간 static 변수는 클래스에서 밖으로 빠져나옴
객체 영역에는 static변수를 제외한 나머지 변수, 메소드들이 저장됨
정적메소드 : 객체 생성없이 사용 가능
<스크린샷_객체생성 메모리흐름 참조>

정적필드는 값이 절대 안바뀌는 것들로 한다. final과 붙여서 쓸것(*******값을 공유할 목적으로 쓰지 말것!!********)
no를 static으로해서 no++이런 식으로 사용x => 즉, 상수 정의할 때 주로 쓴다.


*생성자
Class name = new Class() =>왜 괄호를 붙일까?
-> new 뒤에 클래스를 쓴 것이 아니고 생성자 메서드를 호출해왔던 것! (new 생성자()) -> 단, new와 함께 쓸 때만 사용가능한 메서드
 반환형(void포함) 없다.
객체 생성 직후 바로 실행되는 메서드
생성자는 객체를 생성하는 메서드가 아니다.
 


**학생정보 찾기 
void updateStudent(Student student) {
   Student foundStudent = null;		->초기화 tip*****
   for( Student studentItem : students){
      if(studentItem == null){
         break;
      }
      if(student.name.equals(studentItem.name)){
         foundStudent = studentItem;          
         break;
      }
   }
   if(foundStudent == null){
      sysout("["+student.name+"]"학생이 존재하지 않습니다.
   } else{
       foundStudent.kor = student.kor;
       foundStudent.kor = student.kor;
   }
}

Student student = new Student[100] => 힙에 Student[100]의 메모리를 가리키는 객체 생성(배열0~100 + length등이 포함되어 있음, student[0]의 주소와 Student[100]의 주소는 다름)


문제
1. item클래스에 생성자 정의
2. itemService 클래스의 생성자 메소드에서 items 배열에 미리 item객체를 여러개 저장
3. ItemService와 ItemApp을 순서대로 하나씩 구현

매개변수의 타입이 참조자료형일 때 주소값의 전달
 *주소값을 전달받은 매개변수는 원본 객체를 참조한다.

static메서드는 객체의 다른 멤버변수, 멤버메소드와 상호작용할 필요가 없는 메서드가 사용
멤버메서드에서는 static메서드를 갖다 쓸 수 있음
멤버변수, 멤버메소드를 사용하려면 객체의 생성이 반드시 선행되어야 한다.
정적메소드는 헬퍼클래스, 유틸클래스(여러 클래스에서 공통으로 사용하는 메소드)에 사용한다.
~s 붙는 클래스, ~util 클래스 들은 보통 static 메서드가 모여있다.

=================0401==================================
this: this가 적혀있는 객체의 주소를 가리킨다
cf) static은 객체가 생성이 안돼도 사용 가능 -> 따라서 static메소드에는 this 사용 자체가 불가하다.

this메소드 :
생성자 
public Employee(int no, String name, int salary){
     this(no, name, null, null, salary, 0.0);
}
으로 호출할 경우 : 매개변수에 맞는 생성자에 값을 전달해준다.


Lombok 라이브러리

@Data 		==>해주면 알아서 생성해줌
public class Employee{
    멤버변수
    멤버변수
    멤버변수
}


생성자를 제외하면 매개변수가 너무 많아지면 좋지 않음,
=> 매개변수가 많다면 별도의 클래스로 정의하여 객체로 전달하자


======클래스 설계======
사용자와 상호작용하는 역할 <=====> 사용자의 요청을 처리하는 역할
StudentApp			   StudentService
StudentAndroidApp  	  	   
재사용성, 확장성
==============0402=========================
아마테라스 : https://takezoe.github.io/amateras-update-site/

클래스 간 관계
1. has a 관계 : Book클래스가 Event 클래스를 갖고 있다.(객체로)
2. is a 관계 : 상속의 부모 자식 관계 (해리포터는 Book 이다) 클래스 간 상, 하위의 관계가 형성


==============0405=========================
상속
private은 상속되지 않는다.
상속/구현관계 = is a 관계
     A is a B(A=하위클래스, B=상위클래스)
포함관계 = has a 관계
     A has a B(A=메인클래스, B=부속클래스)
자바는 한개의 상위클래스만 상속받을 수 있다.

@Override는 Annotation
Annotation은 컴파일러, 편집기, 애플리케이션에 부가적 정보를 전달할 목적으로 사용.
어노테이션이 부착된 메소드는 메소드의 반환값, 이름, 매개변수를 상위클래스의 그것과 동일하게 작성해야하며,
다르게 작성시 오류 표시 된다.

단일책임 원칙 : 객체지향의 클래스는 하나의 기능만 수행한다.
ex)
흑백출력
BWPrinter(){
    public void print() { ... }
}

칼라출력
ColorPrinter(){
    public void print() { ... }
}

=> 둘 다 되는 프린터를 만들고 싶으면 Printer 클래스를 만들고 하나씩 가져온다.
둘 다 가능 프린터
Printer(){
     BWPrinter() bwp = new BWPrinter();
     ColorPrinter() cp = new ColorPrinter();
     		...
}

 			접근제한자	반환타입		메소드명		매개변수

중복정의(Overloading) 	상관x		상관x		동일		타입or갯수 달라야한다.
  - 의의 : 유사한 작업을 일관된 이름으로 구현 (구현 내용은 비슷, 파라미터가 다를 때 유용)


재정의(Overriding)		상위클래스와 	동일		동일		동일
      			동일 또는 느슨
  - 의의 : 상/하위 클래스에서 유사한 작업을 일관된 이름과 일관된 사용법으로 구현



*** 형변환

기본자료형의 형변환
	1. 정수 -> 실수
	2. 실수 -> 정수
	3. 정수 -> 문자
	4. 문자 -> 정수
	********위 네가지 경우 말곤 기본자료형의 형변환은 존재하지 않음********

	double x = 1;	
	실수	정수
		실수
	* 1이 1.0으로 데이터 타입 변환됨
	* 1이 1.0으로 변하는 것은 정밀도가 높은 쪽으로, 자료형의 크기가 더 큰 쪽으로 변하는 것이기 때문에
	  데이터 손실 발생x
	* 데이터 손실이 발생하지 않는 형변환은 JVM이 자동으로 수행함
	int x = 3.14
	정수    실수
	
	* 실수가 정수로 데이터타입이 변함
	* 정밀도가 낮은쪽, 데이터 크기가 작은쪽으로 변하기 때문에 데이터 손실 발생가능.
	* 떄문에 JVM이 자동으로 수행하지 않는다.
	* 반드시 형변환 연산자가 필요하다. (int x = (int) 3.14;)

클래스의 형변환
	* 상속관계의 클래스끼리 형변환이 가능하다.
	* 한 가지 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다. 
	* 상위타입의 참조변수로 하위로 만들어진 객체를 참조할 수 있다.
	* 클래스 형변환은 참조변수의 타입과 생성된 객체의 타입이 다를 때 발생한다.(***단 상속관계일 때***)
	   (왼쪽이 부모 오른쪽이 자식)
 	  - ex) LIst list = new ArrayList();	    =>ok
	         Phone phone = new SmartPhone(); =>ok

	         String s = new Phone();  => x
	         System s = new String(); => x
	* 참조변수의 타입과 같은 타입의 객체를 탐색한다.(하위객체에서 상위객체 방향으로 탐색)
	   - 하위 클래스는 상위 클래스를 포함하는 형태
	   - 상위 클래스를 탐색하면 상위 클래스의 주소를 참조한다. 즉 상위 클래스 밖의 메소드, 변수에는 접근이 불가

*****	그럼 왜 이걸 쓸까? *******
	Phone객체를 가리켰다가 필요 시 형변환 연산자를 활용해 하위 클래스의 위치로 이동이 가능하다.

	한 가지 타입으로 변수로 여러 타입의 객체 참조 가능.
	참조변수의 타입으로 참조할 객체의 범위 결정 가능
	ex) Phone[] p = new Phone[100];

	     public class Person{
		phone p ;
	     }

	     public class PhoneTester{
		public boolean testCall(Phone p) { ... }
		public boolean testWeb(SmartPhone p) { ... }
		public boolean testEmail(SmartPhone p) { ... }
		public boolean testFacetime(Iphone p) { ... }
	      }	
	
	Phone p; => Phone 및 Phone의 하위객체를 달라
	

==============0406=========================
Car car1 = new Car();
Car car2 = new PoliceCar();
Car car3 = new Panzer();

->car1같은 경우 형변환할 수 있는 타입이 없다.
->car2 car로 형변환 가능
->car3 car와 panzer로 형변환 가능

cf)
기본 데이터타입의 경우 사이즈도 casting되는 타입간 사이즈도 영향을 미치지만,
클래스의 형변환의 경우 주소를 가리키는 것이기 때문에 객체의 사이즈를 신경 쓸 필요는 없다.

=> 셋 다 바라보는 것은 같으나 생성된 객체는 다 다름.

형변환 방법1.
PoliceCar car22 = (PoliceCar) car2;
car22.patrol();

방법2.
((PoliceCar) car2).patrol(); => 사용 가능(전체를 ()로 감싸야함)
그러나, panzer로는 못간다.

객체안에 특정한 객체가 있는지 확인 : instanceof 연산자 사용(메소드 아님) --> 고유한 기능으로 확장된 클래스의 경우에는 사용 안함
A(참조변수) instanceof B
참조변수가 참조하는 객체에 어떤 객체들이 포함되어 있는지를 확인

참조변수가 참조하는 객체에 B객체가 있으면 True 없으면 false
car instanceof Car	: Car이후 하위객체 전부 false
car instanceof FireTruck : Car, FireTruck만 true
car instanceof PoliceCar
car instanceof Panzer

자식객체를 부모객체에 담는 것은 자동으로 수행된다.
******즉 부모 타입의 객체는 자식 타입의 객체에 담을 수 없다.******


------------------------------상속 경우의 수 ------------------------------
1.
상위클래스 		Class Car{
	공통속성	 		String color;	//공통속성
 	공통기능			void drive() { ... }	//공통기능
				void stop() { ... }
			}

하위 클래스		Class PoliceCar extends Car{
	고유속성			void patrol() {}
	고유기능		}
				
-------------------------------------------------------------------------------
2. 공통된 기능에 대한 상속 
상위클래스 		Class Unit{
	공통속성	 		int life;
 	공통기능			void attack() { ... }	//공통기능
			}

하위클래스		Class Tank extends Unit {
	공통기능에 대한		//메소드 재정의
           고유한 속성, 동작		void attack() {}
			}
-------------------------------------------------------------------------------


변수의 클래스 타입의 범위에서만 조회하지만 오버라이딩 되어 있는 경우는 예외로 오버라이딩 된 메소드를 조회한다. 
최종 재정의 된 메서드만 접근가능(중간 단계의 메서드는 사용불가)
==>메서드는 생성된 객체를 기준으로 실행한다.  => 재정의의 경우 jvm에서 오버라이딩 된 메소드를
가리키게끔 지원해주기 때문에 하위 클래스의 메서드를 사용하기 위해 ******하위 클래스의 주소를 알 필요가 없다.******


**다형성
- 동일한 메시지(메소드)로 목적에 맞는(객체에 맞춰) 여러 행위를 호출할 수 있도록 해줌
- 프로그램 확장성 보장


==============0407=========================


Object[] arr = new Object[10];
  =>아무 객체나 10개 담겠다


---super키워드 ---
this() = 생성자
super()역시 마찬가지로 생성자
생성자 만들 때 항상 super를 따로 정의하지 않으면 super()가 자동으로 삽입된다.
   why? => 자식 객체가 초기화될 때 부모도 초기화 되어야 함
super는 항상 생성자의 첫번째 줄에 적어야 한다.

하위클래스에서 여러가지 형태의 생성자를 쓰기 위해선 상위 클래스에 변수에 맞게 생성자 오버로딩이 되어 있어야 한다.

cf) 최상위 클래스인  Object는 매개변수 없는 기본 생성자 하나뿐이다.


생성자를 super()로 받아오는 경우
super(name);
 부모가 setter를 제공하지 않을 때 상속 받아서 초기화를 하려면 부모클래스에 생성자가 케이스 별로 생성되어 있어야 한다.
  this.name=name; // 부모 클래스의 name이 private일 경우 setter를 쓰면 되지만, setter를 제공하지 않는 클래스가 있을 수도 있다.
	=>예외처리의 경우 setter없이 getter만 제공되어 있다.


패키지는 하나의 디렉토리다
ex) String은 java.lang.String
다른 패키지의 기능을 사용하고자 할 때 import를 사용한다.
lang, 자기패키지 외에는 전부 import 필요
해당 디렉토리의 하위에 있어도 따로 import해야함
ex) import java.util.*; 
     import java.util.time.LocalDate;   => util. 패키지의 기능은 다 불러오지만 util.time이 기능은 따로 임포트해줘야 한다.
cf) 시행시점에 메모리에 로드되기 때문에 임포트가 많다고 해서 성능에 무리를 주진 않음.,
    *을 이용한 import는 사용하지 말것
static import : 소스코드에서 static 변수나 static 메소드를 사용할 때 클래스 이름을 생략하고 사용할 수 있다.


클래스패스: 사용 중인 프로젝트 안에서 접근 가능한 경로
 해당 클래스패스에 등록이 되어 있는 라이브러리만 사용이 가능하다.



---------------------------------추상화-----------------------------------

객체에서 공통된 속성과 기능을 추출함
***단, 구현은 객체에서 하는 것이다.

1. 공통기능
2. 다 똑같은데 한 부분 다를 때

추상메소드
  - 메소드의 구현부가 없는 메소드
  - 추상클래스와 인터페이스에서만 정의할 수 있다. ***
  - 메소드를 정의할 때 abstract 키워드를 메소드 선언부에 추가함
     -> 형식 : 접근제한자 반환타입 메소드명( 타입 변수명, 타입 변수명, ... );
  - 목적 
     * 하위 클래스들이 구현할 메소드에 대한 설계
     * 추상메소드가 포함된 클래스를 상속받은 하위클래스가 자신의 상황에 맞게 구체적으로 구현해야 한다.
     * 추상메소드가 포함된 클래스를 상속받은 하위클래스는 해당 메소드를 반드시 재정의 해야 한다. (안하면 오류뜸)
       (구현클래스는 추상클래스를 포함할 수 없기 때문)**** => 강제성을 가진다.
       -부연 설명: 구현클래스인 하위 클래스가 추상클래스를 상속받기 때문에 구현클래스에 추상 메소드를 갖고 온 꼴이 되어 오류가 발생한다
         때문에 반드시 추상메소드로 선언된 메소드를 오버라이딩하게끔 강제한다

추상클래스
  - 불완전한 설계도
  - 추상메소드, 구현메소드 둘 다 보유할 수 있다
  - new연산자를 사용한 객체 생성이 불가하다. ***
  - 클래스 정의할 때 abstract 키워드를 클래스 선언부에 추가함
     -> 형식 : 접근제한자 abstract class 클래스명{ }
  - 추상메소드가 포함된 클래스를 상속받은 하위클래스(구현클래스)는 사용방법이 동일한 구현메소드를 가지게 된다

==> 메소드는 구현부보다 선언부가 더 중요하다****
<->

구현클래스
  - 완전한 설계도다
  - 구현메소드만 보유할 수 있다
====================================================
값을 담는 객체가 아닐 경우, 변수에 담아서 사용



=====================0408=========================

-------------------------------인터페이스-----------------------------------
인터페이스는 추상메소드와 상수(final)만 갖을 수 있다. <-> 추상클래스는 멤버변수ok
(1.8이후부터는 default키워드와 함께 구현메소드도 추가 가능하지만, 잘 사용하지 않는다.)


-표준화를 위해 사용
-독립적인 프로그램

1. 인터페이스에서는 무조건 abstract만 사용된다.
2. 인터페이스의 접근제한자는 무조건 public이다
   =>보통 public abstract는 생략하고 씀

개방 폐쇄의 원칙 : 독립적인 프로그래밍이 가능함
ex) 인터페이스를 활용한 개발자는 인터페이스를 만든 개발자의 표준안만 이해하고 
     구현은 신경쓰지않고 그저 사용하면 된다.

클래스와 클래스가 결합되어 있는 경우 => 결합도가 높다
클래스가 인터페이스를 참조하는 경우 => 결합도가 낮다.
=> 결합도가 낮은 구현이 개발 속도, 효율이 더 좋다 할 수 있음 (객체지향에서)


클래스는 여러개의 interface를 구현할 수 있다. <-> 한개의 클래스만 상속할 수 있는 것과 차이
인터페이스는 다중 상속이 된다.**(클래스와의 차이점)
수행문이 하나도 없어도 구현부가 있으면 구현 메소드다.
tip) mockito: 테스트케이스 손 쉽게 만들어줌

 Value Object : 값을 담고 있는 객체 (User, VO)
 DataAccess Object : 데이터와 연결하는 객체 (UserArrayRepository (~DAO))
 Service Object : 서비스 객체 (UserManager, Business logic이 구현)
 User Interface : 사용자가 사용할 ui 담당 (UserManagerApp, => (나중에는) Browser web이 됨)
 DataAccess Object Interface :  (UserRepository)

구현이 된 클래스는 뒤에 Impl 붙여준다

Repository는
1. DB제품별로 구현 클래스를 나누거나 (Oracle, MySQL, MongoDBRepository...등등)
2. 사용기술별로 구현 클래스를 나눈다. (Mybatis, JPA Repository... 등등)

UserManager는 어떤 객체가 자신에게 조립되는지 모른다. 
(= UserManager와 구현객체(UserRepository의 구현객체)는 느슨하게 결합되어 있다.)


인터페이스의 종류 
	- 마크업 인터페이스 (강제성은 없음)
		*상수, 추상메소드 등이 하나도 없는 인터페이스
		public interface Serializable {
			//아무것도 없음
			//네트워크를 통해 주고받을 수 있음을 명시하고 싶을 때 사용
		}
		
		public interface Clonable {
			//아무것도 없음
			//복제할 수 있음을 명시하고 싶을 때 사용
		}
	
	- 함수형 인터페이스
		* 추상메소드를 딱 하나만 가지고 있는 인터페이스

	- 그 외
		* 상수, 추상메소드를 한 개 이상 가지고 있는 인터페이스

implements 되는 순간 인스턴스 객체가 생성됨(=>instanceof 사용가능)


interface는 왜 다중상속이 될까?
ex. 자동차
운행기능
정지기능
속도증가기능
속도감소기능
기능이 많아질 경우 인터페이스를 합쳐주지 않으면 구현 부담이 커진다
=>클래스는 단일상속만 되기 때문에 다중상속을 받은 인터페이스의 구현을 한 클래스를 상속하여 구현 부담을 줄일 수 있다.

상속보단 조립의 형태가 나은 경우가 많음

1. 자동차의 기능이 여러 인터페이스로 분리됨
2. 각각의 인터페이스에 대한 다양한 구현클래스가 존재함
3. 소나타 클래스는 순수 자동차의 운행에 관한 부분만 구현함
4. 소나타는 필요한 기능이 구현된 구현체를 참조하는 참조변수만 정의하면 됨
5. 참조변수는 인터페이스 타입으로 정의함으로써 해당 인터페이스를 구현한 어떤 구현체라도 조립될 수 있음
6. 소나타의 구현부담이 감소되고, 소나타가 필요로하는 기능들을 다양하게 조립할 수 있음


=====================0409=========================
-------------------------------인터페이스,의존성주입-----------------------------------

DI(Dependency Injection): 제 3자로부터 '객체'를 얻어서 갖다가 주입하는 것
DL(Dependency LookUp):  내가 직접 객체를 찾아 쓰는 것

구현한 인터페이스에 디폴트 메소드가 있고 그 메소드와 같은 이름의 다른 메소드를 구현한 
클래스를 조상으로 상속관계에 있는 클래스가 만들어진다면, 이 클래스는 디폴트 메소드를 무시하고,
조상클래스의 메소드를 상속한다.




-------------------------------내부클래스-----------------------------------
외부 클래스의 객체 생성없이 모든 변수, 메소드를 갖다 내부클래스 안에서 자유롭게
가져다 쓸 수 있음
public class Outer {
	int x; 
	static int y;
	//인스턴스 내부 클래스
	class Inner{
		void test3(){
		// 외부클래스의 모든 변수, 모든 메소드 사용가능
		  x, y, test1(), test2() 전부 접근가능
		}
	}
}

스태틱 내부 클래스는 static Inner(),static Outer() 클래스의 멤버만 접근이 가능하다.

로컬 내부 클래스(메소드 내부에 선언된 내부클래스) 내부클래스가 포함된 클래스의 멤버, 메소드의 변수에 
모두 접근이 가능하지만, 값이 바뀌는 변수에는 접근이 불가하다.

내부클래스의 실행파일은 내부클래스, 외부클래스 각각 따로 생긴다.
내부와 외부클래스의 경계는 $가 붙음

굳이 외부클래스로 안빼도 되는 클래스를 하나의 클래스 내부에서 해결할 수 있다.

은닉화된 요소에 접근이 가능하게하고, 코드의 복잡성은 감춘다.